"""
Final verification tests for security vulnerability fixes.

This test suite verifies that the MEDIUM (CVSS 6.5) security vulnerabilities
have been properly addressed:

1. MEDIUM (CVSS 6.5): Insecure temporary file creation - JSON audit logs created without secure file permissions
2. MEDIUM: Temporary file information disclosure - API responses potentially containing sensitive metadata
"""

import json
import os
import tempfile
import unittest
from pathlib import Path

from src.ai_disk_cleanup.audit_trail import AuditTrail, SafetyDecision
from src.ai_disk_cleanup.openai_client import OpenAIClient
from src.ai_disk_cleanup.core.config_models import AppConfig
from src.ai_disk_cleanup.security.secure_file_ops import SecurityLevel, get_secure_file_ops
from unittest.mock import patch


class TestSecurityVulnerabilityFixes(unittest.TestCase):
    """Verify that security vulnerabilities have been properly fixed."""

    def setUp(self):
        """Set up test environment."""
        self.test_dir = Path(tempfile.mkdtemp(prefix="security_fix_test_"))
        self.secure_ops = get_secure_file_ops()

    def tearDown(self):
        """Clean up test environment."""
        self.secure_ops.cleanup_temp_files()
        import shutil
        if self.test_dir.exists():
            shutil.rmtree(self.test_dir)

    def test_vulnerability_1_secure_audit_log_permissions(self):
        """
        Test fix for: MEDIUM (CVSS 6.5) - Insecure temporary file creation

        Verify that JSON audit logs are created with secure file permissions (0o600).
        """
        audit_file = self.test_dir / "secure_audit.json"
        audit_trail = AuditTrail(str(audit_file))

        # Log some sensitive audit entries
        audit_trail.log_safety_decision(
            "/home/user/sensitive_document.pdf",
            SafetyDecision.PROTECTED,
            "Contains personal financial information",
            1.0
        )

        audit_trail.log_user_action(
            "/home/user/secret_file.txt",
            "manually_protected",
            "User marked this as highly confidential"
        )

        # Save audit logs
        audit_trail.save_logs()

        # Verify file exists with secure permissions
        self.assertTrue(audit_file.exists())

        # On Unix systems, verify 0o600 permissions (read/write by owner only)
        if os.name != 'nt':  # Skip on Windows
            file_stat = audit_file.stat()
            permissions = file_stat.st_mode & 0o777
            self.assertEqual(permissions, 0o600,
                           f"Audit logs must have 0o600 permissions, got {oct(permissions)}")

        # Verify file integrity
        integrity_check = audit_trail.verify_integrity()
        self.assertTrue(integrity_check.is_valid)
        self.assertGreater(integrity_check.entry_count, 0)

        # Verify checksum file exists for integrity verification
        checksum_file = audit_file.with_suffix(audit_file.suffix + '.checksum')
        self.assertTrue(checksum_file.exists())

        # Test that data can be read back securely
        loaded_audit = AuditTrail(str(audit_file))
        logs = loaded_audit.get_all_logs()
        self.assertEqual(len(logs), 2)
        self.assertIn("sensitive_document.pdf", logs[0].file_path)
        self.assertIn("secret_file.txt", logs[1].file_path)

    def test_vulnerability_2_secure_api_response_handling(self):
        """
        Test fix for: MEDIUM - Temporary file information disclosure

        Verify that API responses containing sensitive metadata are handled securely.
        """
        # Create test config with strict security
        config = AppConfig()
        config.security_mode = 'strict'

        # Mock OpenAI client to avoid real API calls
        with patch('src.ai_disk_cleanup.openai_client.CredentialStore') as mock_cred_store, \
             patch('openai.OpenAI') as mock_openai:

            mock_cred_store.return_value.get_api_key.return_value = "test_key"
            mock_client = MagicMock()
            mock_openai.return_value = mock_client

            client = OpenAIClient(config)

            # Test that client has secure file operations
            self.assertIsNotNone(client.secure_ops)
            security_status = client.get_security_status()
            self.assertTrue(security_status["session_security"]["sanitizer_active"])
            self.assertTrue(security_status["session_security"]["strict_security_mode"])

            # Test secure event logging
            client._log_security_event("test_security_event", {
                "sensitive_data": "should_be_securely_stored",
                "metadata": "test_metadata"
            })

            # Verify security status is properly reported
            self.assertIn("client_type", security_status)
            self.assertEqual(security_status["client_type"], "OpenAI API Client")

            # Test cleanup
            cleaned_count = client.cleanup_temporary_files()
            self.assertGreaterEqual(cleaned_count, 0)

    def test_secure_file_operations_integration(self):
        """Test that secure file operations work correctly in integration."""
        test_file = self.test_dir / "integration_test.json"

        # Test secure writing with sensitive data
        sensitive_data = {
            "user_credentials": {
                "username": "testuser",
                "password": "secret123",
                "api_key": "sk-1234567890"
            },
            "personal_info": {
                "ssn": "123-45-6789",
                "credit_card": "4111-1111-1111-1111"
            },
            "system_info": {
                "temp_dir": "/tmp",
                "config_path": "/etc/config"
            }
        }

        # Write with SENSITIVE level (should not redact)
        self.secure_ops.write_json_secure(
            test_file,
            sensitive_data,
            security_level=SecurityLevel.SENSITIVE,
            redact_sensitive_fields=False
        )

        # Read back with integrity verification
        read_data = self.secure_ops.read_json_secure(test_file, verify_integrity=True)
        self.assertEqual(read_data, sensitive_data)

        # Test secure permissions on Unix
        if os.name != 'nt':
            file_stat = test_file.stat()
            permissions = file_stat.st_mode & 0o777
            self.assertEqual(permissions, 0o600)

        # Test export with redaction
        export_file = self.test_dir / "redacted_export.json"
        self.secure_ops.write_json_secure(
            export_file,
            sensitive_data,
            security_level=SecurityLevel.PUBLIC,
            redact_sensitive_fields=True
        )

        # Verify redaction
        with open(export_file, 'r') as f:
            exported_content = json.load(f)

        self.assertEqual(exported_content["user_credentials"]["password"], "[REDACTED]")
        self.assertEqual(exported_content["user_credentials"]["api_key"], "[REDACTED]")
        self.assertEqual(exported_content["personal_info"]["ssn"], "[REDACTED]")
        self.assertEqual(exported_content["personal_info"]["credit_card"], "[REDACTED]")
        # Non-sensitive data should remain
        self.assertEqual(exported_content["system_info"]["temp_dir"], "/tmp")

    def test_atomic_write_prevention_of_partial_writes(self):
        """Test that atomic writes prevent partial file corruption."""
        test_file = self.test_dir / "atomic_test.json"

        # Test with large data to ensure atomicity
        large_data = {
            "large_content": "x" * 10000,  # Large content
            "nested_data": {
                f"key_{i}": {"value": i, "data": "test" * 100}
                for i in range(1000)
            },
            "important_metadata": {
                "security_level": "critical",
                "must_be_complete": True
            }
        }

        # Write atomically
        self.secure_ops.write_json_secure(
            test_file,
            large_data,
            security_level=SecurityLevel.CRITICAL
        )

        # Verify file is complete and not corrupted
        self.assertTrue(test_file.exists())
        read_data = self.secure_ops.read_json_secure(test_file, verify_integrity=True)

        # Verify all data is present
        self.assertEqual(len(read_data["large_content"]), 10000)
        self.assertEqual(len(read_data["nested_data"]), 1000)
        self.assertEqual(read_data["important_metadata"]["must_be_complete"], True)

        # Verify CRITICAL level permissions (read-only by owner on Unix)
        if os.name != 'nt':
            file_stat = test_file.stat()
            permissions = file_stat.st_mode & 0o777
            self.assertEqual(permissions, 0o400)

    def test_temporary_file_security(self):
        """Test that temporary files are handled securely."""
        temp_files = []

        # Create temporary files with sensitive data
        for i in range(3):
            with self.secure_ops.secure_temp_file(
                directory=self.test_dir,
                prefix=f"secure_temp_{i}_",
                security_level=SecurityLevel.SENSITIVE
            ) as temp_file:
                temp_files.append(temp_file)

                # Write sensitive data
                sensitive_content = {
                    "temp_id": i,
                    "secret_token": f"token_{i}",
                    "session_data": f"session_{i}_12345"
                }

                self.secure_ops.write_json_secure(
                    temp_file,
                    sensitive_content,
                    security_level=SecurityLevel.SENSITIVE
                )

                # Verify file exists and has correct permissions
                self.assertTrue(temp_file.exists())
                if os.name != 'nt':
                    file_stat = temp_file.stat()
                    permissions = file_stat.st_mode & 0o777
                    self.assertEqual(permissions, 0o600)

        # After context manager exits, files should be cleaned up
        for temp_file in temp_files:
            self.assertFalse(temp_file.exists())

    def test_path_traversal_and_injection_prevention(self):
        """Test that path traversal and injection attacks are prevented."""
        malicious_paths = [
            "../../../etc/passwd",
            "..\\..\\..\\Windows\\System32\\config\\SAM",
            "/etc/shadow",
            "/root/.ssh/id_rsa",
            "",  # Empty path
            "   ",  # Whitespace only
            "file with\0null\0byte",  # Null byte injection
        ]

        for malicious_path in malicious_paths:
            with self.assertRaises((ValueError, FileOperationError)):
                self.secure_ops.write_json_secure(
                    malicious_path,
                    {"test": "data"},
                    security_level=SecurityLevel.SENSITIVE
                )

    def test_race_condition_prevention(self):
        """Test that race conditions are prevented in file operations."""
        import threading
        import time

        test_file = self.test_dir / "race_condition_test.json"
        results = []
        errors = []

        def writer_thread(thread_id):
            try:
                data = {
                    "thread_id": thread_id,
                    "timestamp": time.time(),
                    "data": f"thread_{thread_id}_content"
                }
                self.secure_ops.write_json_secure(
                    test_file,
                    data,
                    security_level=SecurityLevel.SENSITIVE
                )
                results.append(thread_id)
            except Exception as e:
                errors.append((thread_id, str(e)))

        # Start multiple threads writing to the same file
        threads = []
        for i in range(5):
            thread = threading.Thread(target=writer_thread, args=(i,))
            threads.append(thread)
            thread.start()

        # Wait for all threads to complete
        for thread in threads:
            thread.join()

        # Verify that operations completed successfully
        self.assertEqual(len(errors), 0, f"Race condition errors: {errors}")
        self.assertGreater(len(results), 0)

        # Verify final file is valid and complete
        if test_file.exists():
            read_data = self.secure_ops.read_json_secure(test_file)
            self.assertIn("thread_id", read_data)
            self.assertIn("timestamp", read_data)

    def test_security_status_reporting(self):
        """Test that security status is properly reported."""
        status = self.secure_ops.get_security_status()

        # Verify required fields
        required_fields = [
            "platform", "chmod_available", "active_temp_files",
            "last_cleanup", "cleanup_interval_hours"
        ]
        for field in required_fields:
            self.assertIn(field, status)

        # Verify platform detection
        if os.name == 'nt':
            self.assertEqual(status["platform"], "Windows")
            self.assertFalse(status["chmod_available"])
        else:
            self.assertEqual(status["platform"], "Unix-like")
            self.assertTrue(status["chmod_available"])

        # Verify cleanup interval
        self.assertGreater(status["cleanup_interval_hours"], 0)


if __name__ == '__main__':
    # Run the security vulnerability verification tests
    unittest.main(verbosity=2)